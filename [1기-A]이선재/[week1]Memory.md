# CS 스터디 메모리 포스팅

# 1. 메모리란?

## 개요

저는 평소 컴퓨터의 메모리를 많이 들었지만 `무엇을 하는지 정확히 몰랐습니다`.  하지만 학교에서도 CS관련 지식을 학습이 미흡했고, 지금까지 메모리에 대해 아는것을`방치`해왔습니다. 이번 스터디를 통해 `궁금증을 해결하고자 메모리를 주제로`정하게 됐습니다.

## 정의

정보를 저장하고 필요한 시점에 꺼내어 쓸 수 있는 하드웨어로써 ‘기억 장치’라고도 합니다.

## 역할

실행할 프로그램을 저장하고 있고, 읽고 쓰는 데이터를 쓰기도 합니다.

### 프로세스 메모리 구조

![Untitled](https://user-images.githubusercontent.com/63578094/128635336-8dc63b6b-e12a-4fc0-9c96-4de6708879ab.png)


이 그림은 오늘날 사용하고 있는 대부분의 컴퓨터의 기본 구조인 `폰노이만 구조`입니다. 주기억 장치, 중앙 처리 장치, 입출력 장치의 `전형적인 3단계 구조`로 이루어진 프로그램 `내장형 컴퓨터 구조`입니다.

1. **버스**가 오직 하나이기 때문에 명령어와 데이터가 같은 메모리에 저장됩니다.
2. 명령어와 데이터가 하나의 메모리 시스템을 공유합니다.
3. 데이터 전송, 명령어 불러오기를 예약할 수 있다. 단, 이를 수행하려면 두 작업이 동시에 수행되지 말아야 합니다.

## 메모리 종류

![Untitled 1](https://user-images.githubusercontent.com/63578094/128635344-76194649-be69-44b4-8360-0988a3eef2ba.png)


### RAM

전원이 끊어지면 기억되어있는 데이터들이 소멸되기 때문에 `휘발성 메모리(Volatile Memory)`라 표현합니다.
데이터를 `읽는 속도와 기록하는 속도가 같으`며, 컴퓨터의 주기억장치, 응용 프로그램 로딩, 데이터 일시 저장 등과 같은 곳에 사용됩니다.

### ROM

전원이 끊어져도 기록된 데이터들이 소멸되지 않는 `비휘발성 메모리(Non-Volatile Memory)`입니다.
 ROM에 데이터를 (반영구적으로) 저장한 후 이를 `지속적으로 사용`하게 됩니다. 컴퓨터의 바이오스롬도 이에 속합니다.

### RAM과 ROM의 차이점(비교하며 알아보기)

![Untitled 2](https://user-images.githubusercontent.com/63578094/128635353-6267f1e5-1974-4ee0-9ed4-a6e0b73a1b9a.png)

# 2.메모리 관리 전략

## 메모리 관리 배경

![Untitled 3](https://user-images.githubusercontent.com/63578094/128635369-fdd8395d-9365-4e53-905e-3b72fee5a43a.png)

1. 일괄처리 환경에서 최초의 단일 프로그래밍은 오로지 `하나의 프로세스만이 메모리에 적재`될 수 있었으므로 특별한 메모리 관리 정책이 필요하지 않습니다. 
2. 하지만 이후 모든 운영체제 유형의 기본이 되는 `다중 프로그래밍 환경`이 발전되어 메모리에 `여러 개의 프로세스가 동시에 적재`되는 시스템 환경에서는 필요하게 됐습니다.
3. 그래서 어느 프로세스를 어느 부분에 어떻게 적재할 것인가 하는 메모리 관리 전략이 `필요`하게 됐습니다.

## 연속 메모리 할당(고정 분할, 가변 분할)

### 고정 분할

- `메모리를 미리 고정적으로 분할`시켜 놓고, 공간이 비워질 때마다 새로운 프로그램을 적재하는 방법입니다.
- 내부 단편화
아래 그림과 같이 50MB의 빈 공간에 30MB의 작업이 들어왔을 때 20MB가 남는 현상을 보아 사용자 프로그램의 크기에 꼭 맞는 메모리를 제공할 수 없으므로 메모리 일부를 활용하지 못하는 데 있습니다. 이와 같은 현상을 내부 단편화라고 합니다.

![Untitled 4](https://user-images.githubusercontent.com/63578094/128635374-050abae2-342a-4bb5-ba04-953b21adc809.png)

### 가변 분할

- 고정 분할의 내부 단편화를 해결하기 위해 비어있는 공간을 정확히 프로그램의 크기만큼 할당하는 방법입니다.
- 할당과 반납이 진행되면서 크기가 아주 작은 빈 분할들이 늘어나 이들이 비어있는데도 불구하고 활용되지 못하는 상황이 발생합니다. 아래 그림처럼 50MB + 50MB 총 100MB가 있지만 70MB가 할당되지 못하는 현상을 외부 단편화라고 합니다.
- 외부단편화 문제를 완화하기 위해서는 적절한 할당 정책과 빈공간의 병합 및 통합이 필요합니다.

![Untitled 5](https://user-images.githubusercontent.com/63578094/128635378-9328754c-7cdd-4f2f-9bfd-49c50c49d1d4.png)

# 불연속 메모리 할당(페이징, 세그먼테이션)

## 페이징

- 메모리를 자르는 것이 아닌 `프로세스를 일정 크기인 페이지로 잘라`서 메모리에 적재하는 방식입니다.
- 프로세스를 자르면 실행이 안 된다고 의문이 들 수 있습니다. 하지만 그렇게 할 수 있는 이유는 MMU의 재배치 레지스터의 값을 바꾸어 CPU에게 `하나의 프로세스가 할당됐다고 속일` 수 있기 때문에 가능합니다.
- 하지만 페이징에도 저장공간이 낭비되는 단점이 있습니다. 만약 프로세스가 15Byte인데 4Byte단위로 나뉜다면 마지막 `4Byte는 1Byte는 메모리가 낭비`되어 `내부단편화`가 발생하기 때문입니다.

![Untitled 6](https://user-images.githubusercontent.com/63578094/128635386-b05c688f-e54e-4a29-bced-812c4e23cc74.png)

## 세그먼테이션

- 페이징과 유사한 방식으로 자르지만 논리적 내용 단위인 세그먼트로 자릅니다. `아래 그림을 보시면` 논리적 내용의 단위로 자르기 때문에 세그먼트들의 크기는 일반적으로 같지 않습니다.
- 장점은 세그먼트 테이블 엔트리마다 r,w,x비트를 만들어 해당 세그먼트에 대한 접근 제어 및 공유가 가능해져 메모리를 효과적으로 사용합니다.

![Untitled 7](https://user-images.githubusercontent.com/63578094/128635392-2e5d9afb-7dc2-4b25-bc8a-1195f2a03f13.png)

### 세그먼테이션 + 페이징

1. 프로세스를 처음에 `세그먼트 단위로 자릅니다.` 
2. 의미 있는 단위로 나누게 되면 `보호와 공유를 하는 측면에 이점`을 가질 수 있게 됩니다. 
3. 하지만 앞서 말했듯 외부 단편화가 발생할 수 있다. 그래서 우리는 잘라진 세그먼트를 다시 일정 간격인 `페이지 단위로 자르는 페이징 방법을 시도 합니다.`
4. 그래서 메모리에 적재하면 페이징의 일정 단위로 다시 잘렸기 때문에 `외부 단편화가 발생하지 않습니다.`
5. 하지만 이와 같은 경우에는 테이블을 두 가지를 모두 거쳐야 하므로 `속도 면에서 조금 떨어질 수 있습니다.`

# 가상 메모리

## 가상메모리 개발 배경

1. 실행되는 코드의 전부를 물리 메모리에 존재시켜야 하는 상황 발생
2. 메모리 용량보다 큰 프로그램은 실행시킬 수 없음
3.  여러 프로그램을 동시에 메모리에 올리기에는 용량의 한계와 페이지 교체 등의 성능 이슈가 발생 
4. 가끔만 사용되는 코드가 차지하는 메모리들을 확인할 수 있다는 점에서, 불필요하게 전체의 프로그램이 메모리에 올라와 있어야 하는 게 아니라는 것을 알 수 있습니다.
5. 다중 프로그래밍을 실현하기 위해서는 많은 프로세스들을 동시에 메모리에 올려두어야 했기 때문에 프로세스 전체가 메모리 내에 올라오지 않더라고 실행이 가능하도록 하는 기법인 `가상메모리` 탄생

## 요구 페이징

프로그램 실행 시작 시에 프로그램 전체를 디스크에서 물리 메모리에 적재하는 대신, 초기에 필요한 것들만 적재하는 전략, 사용되지 않을 페이지를 가져오는 시간낭비와 메모리 낭비를 줄일 수 있습니다.

## 페이지 교체

프로그램 실행 시에 모든 항목이 물리 메모리에 올라오지 않기 때문에, 프로세스의 동작에 필요한 페이지를 요청하는 과정에서 page fault(페이지 부재)가 발생하게 되면, 원하는 페이지를 보조 저장 장치에서 가져오게 됩니다. 하지만, 만약 물리 메모리가 모두 사용 중인 상황이라면, 페이지 교체가 이뤄줘야 합니다.

### 페이지 교체 알고리즘

1. FIFO 페이지 교체
    - 먼저 물리 메모리에 들어온 순서대로 페이지 교체 시점에 먼저 나가게 되는 것
2. 최적 페이지 교체
    - 앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체
3. LRU 페이지 교체
    - 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체
4. LFU 페이지 교체
    - 참조 횟수가 가장 적은 페이지를 교체
5. MFU 페이지 교체
- 참조 횟수가 가장 적은 페이지가 최근에 메모리에 올라왔고, 앞으로 계속 사용될 것이라는 가정에 교체

# 스터디 후 소감

저는 지식을 아는 것을 미뤘지만 스터디 발표를 준비하면서 공부한 경험이 저의 속을 뚫어준 느낌을 받았습니다. 메모리라는 주제를 어디 범위까지 설명해야 되고, 발표를 어떻게 해야 되는지 고민을 많이 했습니다. 제가 지식을 알아가며 발표를 준비하는 과정을 통해 `저의 지식을 습득 과정`을 살펴보는 계기가 됐습니다. 🤔

글을 읽을 때 `정독하지 않고 빠르게 넘어가려는` 단점을 깨닫고, `한 줄씩 차례대로 생각해가며 글을 읽어보니` 어려워하던 메모리 개념이 제 `머릿속에 그려지는 것을` 느꼈습니다. 이번 스터디를 통해 메모리 전부를 설명하지는 못했지만 메모리 전략(페이징, 세그먼테이션)을 알게 됐고, 스터디 원들에게 설명하기 위해 계속 읽으며 자연스레 저의 것이 되는 경험을 했습니다.😁 

다음 스터디 주제는 제대로 설명 못했던 가상 메모리를 할 까 고민중입니다. (너무 날먹인가..?)😎

### 참고 자료

> [https://medium.com/@jgj455/computer-science-memory-cpu-d234a24c6560](https://medium.com/@jgj455/computer-science-memory-cpu-d234a24c6560)
[https://wikidocs.net/65522](https://wikidocs.net/65522)
[https://boycoding.tistory.com/260](https://boycoding.tistory.com/260)
[https://m.blog.naver.com/rbdi3222/220623825770](https://m.blog.naver.com/rbdi3222/220623825770)
[https://t1.daumcdn.net/cfile/tistory/27649A47590818AA2D](https://t1.daumcdn.net/cfile/tistory/27649A47590818AA2D)
[https://mblogthumb-phinf.pstatic.net/MjAxODA5MjlfMTgg/MDAxNTM4MjMyMzkyNDE1.rvappISlFrPXvnZDELzE4OxMQhsOLe3QrtZAf6tZIzcg.zJgInqy8RDCz5TuBjFiLIqo9YaoTB94kvItvW7YGaxog.JPEG.qbxlvnf11/8_09_Segmentation.jpg?type=w800](https://mblogthumb-phinf.pstatic.net/MjAxODA5MjlfMTgg/MDAxNTM4MjMyMzkyNDE1.rvappISlFrPXvnZDELzE4OxMQhsOLe3QrtZAf6tZIzcg.zJgInqy8RDCz5TuBjFiLIqo9YaoTB94kvItvW7YGaxog.JPEG.qbxlvnf11/8_09_Segmentation.jpg?type=w800)
[https://velog.io/@deannn/CS-기초-운영체제-메모리-관리-전략#메모리-관리-전략](https://velog.io/@deannn/CS-%EA%B8%B0%EC%B4%88-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EC%A0%84%EB%9E%B5#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EC%A0%84%EB%9E%B5)
